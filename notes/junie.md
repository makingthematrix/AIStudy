# Notes about using Junie

Junie Livestream #1: https://www.youtube.com/watch?v=oUGIcp2Iph0&list=WL&index=1

* You can create a small video game from scratch by simply prompting Junie
* One way to do it is to create a file, e.g. `requirements.md` in the main directory, use it to write a detailed description of the game and feed it to Junie
* Junie takes quite a lot of time to work on the requirements file.
  * First it creates a detailed plan 
  * Then it asks you to accept the plan or add modifications and then recreate the plan
  * After you accept the plan, it creates the project step by step, as it's specified in the plan
  * You can now review it and write a new file with changes requirements (fixes, refactorings, new features)
* It might make sense to create a git repository at the very beginning and then commit the code generated by Junie in each iteration of your work
  * Or even a new branch
* You can even ask Junie to change the requirements file and e.g. mark tasks as done when they are done
* Lol, if you add a header "# VERY IMPORTANT" to a section in requirements.md, Junie will take extra care to implement that section
* I can describe the differences in the workflow between AI Assistant and Junie
* What LLM is under Junie?

Big question: How much does it cost?
* What is the license cost?
* But also, is there a price or limit for used tokens?
* Are there discounts for students and OSS maintainers?

An idea for the video recording part of the talk: 
* Make Junie implement some parts of the functionality and unit tests for the binary tree
* Show that bug where the root value is repeated in the println of the tree
  * If I make Junie generate unit tests, it will generate them such that they will pass with the bug, but fail after I fix it
  * The bug appears because I appended the value twice, in calls to both branches, while it should be used only in the first one:
```scala 3
// bug
val newAcc = serialize(left, s"$acc\n$prefix${toString(value)}", level + 1)
serialize(right, s"$newAcc\n$prefix${toString(value)}", level + 1)
// fixed
val newAcc = serialize(left, s"$acc\n$prefix${toString(value)}", level + 1)
serialize(right, newAcc, level + 1)
```

Example prompt:
Implement an `iterator` method on the Tree object. The iterator implements Scala collections Iterator and its `hasNext` `next` methods. The iterator starts at the left-most leaf. Each call to `next` moves the iterator from the left node of a given parent to the right node, and then, if it's a branch, to the left-most leaf of that branch. Stumps are ignored. If the iterator is already at the right-most leaf of the given branch, a call to `next` will move it one parent up in the tree, and again, to the right branch of that upper parent. `hasNext` is initially true, it turns to false when the iterator reaches the right-most leaf of the tree.

Write a new unit test suite to test the implementation. Call it TreeIteratorSuite and put it next to TreeIntSuite. In the unit tests, use Int as the element of the tree. Generate a sequence of increasingly complex unit tests. The first testing a Stump, then Leaf, then a simple Branch, then a few more complex examples of Branch.

Junie plan (Sonnet 3.7):
1. Understand the requirements for the Tree iterator
- Start at the left-most leaf
- Move from left node to right node of a parent
- If it's a branch, move to the left-most leaf of that branch
- Ignore Stumps
- When at right-most leaf, move up to parent and to right branch
- hasNext is initially true, false when at right-most leaf of tree
2. Examine the Tree.scala file to understand the current implementation
3. Implement the iterator method in Tree.scala
- Create a private helper method to find the left-most leaf
- Implement the iterator method that returns a Scala Iterator
- Implement hasNext and next methods according to requirements
4. Create a new test suite TreeIteratorSuite.scala
5. Implement tests for the iterator:
- Test with Stump
- Test with Leaf
- Test with simple Branch
- Test with more complex Branch structures
6. Run the tests to verify the implementation works correctly
7. Fix issues found during testing
- Fix the `tail of empty list` exception
- Fix the traversal order to match the expected behavior
- Fix the `hasNext` method to return the correct value
- Fix the type parameter issue with Branch pattern matching
8. Run the tests again to verify the fixes

Proposed implementation:
```scala 3
def iterator[T](tree: Tree[T]): Iterator[T] = new Iterator[T]:
    // Stack to keep track of the path from root to current node
    private var stack: List[Tree[T]] = List()

    // Initialize the iterator by finding the left-most path
    {
      var current = tree
      while current != Stump do
        current match
          case Branch(left, _, _) =>
            stack = current +: stack
            current = left
          case Leaf(_) =>
            stack = current +: stack
            current = Stump
          case Stump => // Skip Stumps
        end match
      end while
    }

    override def hasNext: Boolean = stack.nonEmpty

    override def next(): T =
      if !hasNext then throw new NoSuchElementException("No more elements")

      val current = stack.head

      current match
        case Branch(_, value, right) =>
          // Remove the current node from the stack
          stack = stack.tail

          // Add the right subtree to the stack if it's not a Stump
          if right != Stump then
            var node = right
            stack = node +: stack

            // Find the left-most path in the right subtree
            var continueLoop = true
            while continueLoop do
              node match
                case Branch(left, _, _) =>
                  if left != Stump then
                    node = left
                    stack = node +: stack
                  else
                    continueLoop = false
                case _ =>
                  continueLoop = false
            end while
          end if

          value
        case Leaf(value) =>
          // Remove the leaf from the stack
          stack = stack.tail
          value
        case Stump =>
          throw new NoSuchElementException("Stumps should be ignored")
```

Trying to refactor with the following prompt:
Rewrite implementation in a more idiomatic Scala style, using exhaustive pattern matching on enums and immutability. You shouldn't need to have a mutable stack to see if the whole tree was already iterated. Instead, keep a count of already iterated Leafs and compare it to tree.size.

Result:
```scala 3
  def iterator[T](tree: Tree[T]): Iterator[T] = new Iterator[T]:
    // Pre-compute all values in the correct traversal order
    private val values: List[T] = collectValues(tree)
    private var index = 0

    // Collect all values in the tree in the correct traversal order
    private def collectValues(tree: Tree[T]): List[T] = tree match
      case Stump => List.empty
      case Leaf(value) => List(value)
      case Branch(left, value, right) =>
        // Traverse left subtree, then current node, then right subtree
        collectValues(left) ++ List(value) ++ collectValues(right)

    override def hasNext: Boolean = index < values.length
```
Much better, but see what's happening: Junie basically implemented `toList`, but didn't notice that it's `toList` and called it `collectValues`. Then, instead of simply returning the list's iterator, it created its own new iterator - because it was told to implement the counter and check it against tree.size.

Final version:

```scala
  def toList[T](tree: Tree[T]): List[T] = tree match
    case Stump                      => Nil
    case Leaf(value)                => List(value)
    case Branch(left, value, right) => toList(left) ::: List(value) ::: toList(right)

  inline def iterator[T](tree: Tree[T]): Iterator[T] = toList(tree).iterator
```

### Action Allowlist
A list of commands that Junie can execute without confirmation.
You can use regexes. YOu can also run a command to check if it needs confirmation according to the new ruleset.
* Terminal rules
* RunTest rules
* Build rules
* Preview rules (?)